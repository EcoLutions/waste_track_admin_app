import { patchState, signalStore, withComputed, withMethods, withState } from '@ngrx/signals';
import { computed, inject } from '@angular/core';
import { Router } from '@angular/router';
import { ContainerService } from '../../../../../entities';
import { ContainerEntity, ContainerTypeEnum, ContainerStatusEnum } from '../../../../../entities';

export interface CreateContainerState {
  // Form data
  formData: {
    latitude: string;
    longitude: string;
    address: string;
    districtCode: string;
    volumeLiters: number;
    maxWeightKg: number;
    containerType: ContainerTypeEnum;
    sensorId: string;
    districtId: string;
    collectionFrequencyDays: number;
  };

  // UI state
  isLoading: boolean;
  error: string | null;
  isSuccess: boolean;
}

const initialState: CreateContainerState = {
  formData: {
    latitude: '',
    longitude: '',
    address: '',
    districtCode: '',
    volumeLiters: 240,
    maxWeightKg: 100,
    containerType: ContainerTypeEnum.GENERAL,
    sensorId: '',
    districtId: '',
    collectionFrequencyDays: 7
  },
  isLoading: false,
  error: null,
  isSuccess: false
};

export const CreateContainerStore = signalStore(
  { providedIn: 'root' },

  // State
  withState(initialState),

  // Computed properties
  withComputed((state) => ({
    isFormValid: computed(() => {
      const form = state.formData();
      return form.latitude.trim() !== '' &&
             form.longitude.trim() !== '' &&
             form.address.trim() !== '' &&
             form.districtCode.trim() !== '' &&
             form.volumeLiters > 0 &&
             form.maxWeightKg > 0 &&
             form.districtId.trim() !== '' &&
             form.collectionFrequencyDays > 0;
    }),

    containerPreview: computed((): Partial<ContainerEntity> => {
      const form = state.formData();
      return {
        latitude: form.latitude,
        longitude: form.longitude,
        address: form.address,
        districtCode: form.districtCode,
        volumeLiters: form.volumeLiters,
        maxWeightKg: form.maxWeightKg,
        containerType: form.containerType,
        status: ContainerStatusEnum.ACTIVE,
        currentFillLevel: 0,
        sensorId: form.sensorId || null,
        districtId: form.districtId,
        collectionFrequencyDays: form.collectionFrequencyDays,
        lastReadingTimestamp: null,
        lastCollectionDate: null,
        createdAt: null,
        updatedAt: null,
        id: 'preview'
      };
    })
  })),

  // Methods
  withMethods((store) => {
    const containerService = inject(ContainerService);
    const router = inject(Router);

    return {
      // Form actions
      updateFormField<K extends keyof CreateContainerState['formData']>(
        field: K,
        value: CreateContainerState['formData'][K]
      ): void {
        patchState(store, (state) => ({
          formData: {
            ...state.formData,
            [field]: value
          }
        }));
      },

      updateFormData(formData: Partial<CreateContainerState['formData']>): void {
        patchState(store, (state) => ({
          formData: {
            ...state.formData,
            ...formData
          }
        }));
      },

      resetForm(): void {
        patchState(store, {
          formData: initialState.formData,
          error: null,
          isSuccess: false
        });
      },

      // Container creation
      async createContainer(): Promise<void> {
        if (!store.isFormValid()) {
          patchState(store, {
            error: 'Por favor complete todos los campos requeridos'
          });
          return;
        }

        patchState(store, {
          isLoading: true,
          error: null
        });

        try {
          const formData = store.formData();

          // Create container entity from form data
          const containerEntity: ContainerEntity = {
            id: '', // Will be generated by backend
            latitude: formData.latitude,
            longitude: formData.longitude,
            address: formData.address,
            districtCode: formData.districtCode,
            volumeLiters: formData.volumeLiters,
            maxWeightKg: formData.maxWeightKg,
            containerType: formData.containerType,
            status: ContainerStatusEnum.ACTIVE,
            currentFillLevel: 0,
            sensorId: formData.sensorId || null,
            lastReadingTimestamp: null,
            districtId: formData.districtId,
            lastCollectionDate: null,
            collectionFrequencyDays: formData.collectionFrequencyDays,
            createdAt: null,
            updatedAt: null
          };

          containerService.create(containerEntity).subscribe({
            next: (createdContainer) => {
              patchState(store, {
                isLoading: false,
                isSuccess: true,
                error: null
              });

              // Navigate to container monitoring after successful creation
              setTimeout(() => {
                router.navigate(['/containers']);
              }, 1500);
            },
            error: (error) => {
              patchState(store, {
                isLoading: false,
                error: error.message || 'Error al crear el contenedor',
                isSuccess: false
              });
            }
          });

        } catch (error) {
          patchState(store, {
            isLoading: false,
            error: 'Error inesperado al crear el contenedor',
            isSuccess: false
          });
        }
      },

      // Utility methods
      setError(error: string | null): void {
        patchState(store, { error });
      },

      setLoading(loading: boolean): void {
        patchState(store, { isLoading: loading });
      }
    };
  })
);
